# -*- coding: utf-8 -*-
"""airport_ml.pynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CzF6uNO6u6v5ZC4BPCdYFW0P-ob-MXu6
"""

#!pip install -r "/content/drive/MyDrive/Colab Notebooks/LEVX_1km/requirements.txt"

#@title Operational
import streamlit as st
from st_aggrid import AgGrid
import os
import sys
import numpy as np
import pandas as pd
from datetime import timedelta
from io import BytesIO
import base64
import pickle
import warnings
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import accuracy_score
from sklearn.metrics import mean_absolute_error
from help_functions import *


warnings.filterwarnings("ignore")
st.set_page_config(page_title="Airport Machine Learning forecast",layout="wide")




options = ["LECO", "LEST", "LEBL","LEVX"]
default_option = options[0]  # Set the default option

# Create a radio button to select the string variable
OACI = st.radio("Select airport", options, index=0)

print(OACI, "AIRPORT")

#score machine learning versus WRF
score_ml = 0
score_wrf = 0
best_ml = []
best_wrf = []

# Set the directory you want to list algorithms filenames from
algo_dir = OACI+"/algorithms/"

#get meteorological model from algorithm file. Select "coor" key to get coordinates. Pick up first algorithm all same coordinates

#grid type
k4 = ["LECO","LEST"]
k12 = ["LEBL"]
k1 = ["LEVX"]

if OACI in k4:
    meteo_model,con = get_meteogalicia_model_4Km(pickle.load(open(algo_dir+os.listdir(algo_dir)[0],"rb"))["coor"])
if OACI in k12:
    meteo_model,con = get_meteogalicia_model_12Km(pickle.load(open(algo_dir+os.listdir(algo_dir)[0],"rb"))["coor"])
if OACI in k1:
    meteo_model,con = get_meteogalicia_model_1Km(pickle.load(open(algo_dir+os.listdir(algo_dir)[0],"rb"))["coor"])
    

#add time variables
meteo_model["hour"] = meteo_model.index.hour
meteo_model["month"] = meteo_model.index.month
meteo_model["dayofyear"] = meteo_model.index.dayofyear
meteo_model["weekofyear"] = meteo_model.index.isocalendar().week.astype(int)
print("meteorological model info")
print(meteo_model.info())
metars = get_metar(OACI,con)
st.markdown(" ### **Metars**")
AgGrid(metars[["metar_o","dir_o","spd_o","gust_o","visibility_o","wxcodes_o","skyc1_o","skyl1_o","skyc2_o","skyl2_o","temp_o","tempd_o","mslp_o"]])

#@title Wind direction
st.markdown(" #### **Wind direction**")
#open algorithm dir d0 d1
alg = pickle.load(open(algo_dir+"dir_"+OACI+"_d0.al","rb"))
alg1 = pickle.load(open(algo_dir+"dir_"+OACI+"_d1.al","rb"))

#select model variables
model_x_var = meteo_model[:24][alg["x_var"]]
model_x_var1 = meteo_model[24:48][alg1["x_var"]]

# forecat spd from ml
dir_ml = alg["pipe"].predict(model_x_var)
dir_ml1 = alg1["pipe"].predict(model_x_var1)

#set up dataframe forecast machine learning and WRF
df_for = pd.DataFrame({"time":meteo_model[:48].index,
                        "dir_WRF": np.concatenate((model_x_var["dir0"],model_x_var1["dir0"]),axis=0),
                        "dir_ml": np.concatenate((dir_ml,dir_ml1),axis =0),})
df_for = df_for.set_index("time")

#label dir_o and dir0 .wind direction to interval dir=-1 variable wind
interval = pd.IntervalIndex.from_tuples([(-1.5, -0.5),(-0.5,20), (20, 40), (40, 60),
                                           (60,80),(80,100),(100,120),(120,140),(140,160),
                                           (160,180),(180,200),(200,220),(220,240),
                                           (240,260),(260,280),(280,300),(300,320),
                                           (320,340),(340,360)])
labels = ['VRB', '[0, 20]', '(20, 40]', '(40, 60]','(60, 80]', '(80, 100]',
          '(100, 120]', '(120, 140]','(140, 160]', '(160, 180]', '(180, 200]',
          '(200, 220]','(220, 240]', '(240, 260]', '(260, 280]', '(280, 300]',
          '(300, 320]', '(320, 340]', '(340, 360]']
df_for["dir_WRF_l"] = pd.cut(df_for["dir_WRF"], bins=interval,retbins=False,
                        labels=labels).map({a:b for a,b in zip(interval,labels)}).astype(str)

#dir_o to intervals
metars["dir_o_l"] = pd.cut(metars["dir_o"].replace("M",-1).astype(float), bins=interval,retbins=False,
                        labels=labels).map({a:b for a,b in zip(interval,labels)}).astype(str)

# concat metars an forecast
df_res = pd.concat([df_for,metars[["dir_o","dir_o_l"]]],axis = 1)

#get accuracy
df_res_dropna = df_res.dropna()
acc_ml = round(accuracy_score(df_res_dropna.dir_o_l,df_res_dropna.dir_ml),2)
acc_wrf = round(accuracy_score(df_res_dropna.dir_o_l,df_res_dropna.dir_WRF_l),2)
if acc_ml>acc_wrf:
  score_ml+=1
  best_ml.append("wind direction")
if acc_ml<acc_wrf:
  score_wrf+=1
  best_wrf.append("wind direction")

#Show results
fig, ax = plt.subplots(figsize=(10,6))
plt.plot(df_res_dropna.index, df_res_dropna['dir_ml'], marker="^", markersize=8,
         markerfacecolor='w', color="b", linestyle='')
plt.plot(df_res_dropna.index, df_res_dropna['dir_o_l'], marker="*", markersize=13,
         markerfacecolor='k', color= "g", linestyle='');
plt.plot(df_res_dropna.index, df_res_dropna['dir_WRF_l'], marker="v", markersize=8,
         markerfacecolor='w', color="r", linestyle='');
plt.legend(('direction ml', 'direction observed', 'direction WRF'),)
plt.grid(True, axis="both", which="both")

# score references met model and machine learning
ref_met0 = alg["score"]["acc_met"]
ref_ml0 = alg["score"]["acc_ml"]
ref_met1 = alg1["score"]["acc_met"]
ref_ml1 = alg1["score"]["acc_ml"]
plt.title("Actual accuracy meteorological model: {:.0%}. Reference (D0): {:.0%}. Reference (D1): {:.0%}\nActual accuracy machine learning: {:.0%}. Reference (D0): {:.0%}. Reference (D1): {:.0%} ".format(acc_wrf,ref_met0,ref_met1,acc_ml,ref_ml0,ref_ml1))
#plt.show(fig)
st.pyplot(fig)

fig, ax = plt.subplots(figsize=(10,6))
plt.plot(df_for.index, df_for['dir_ml'],marker="^", color="b", linestyle='');
plt.plot(df_for.index, df_for['dir_WRF_l'],marker="v",color="r", linestyle='');
plt.legend(('direction ml','direction WRF'),)
plt.title("Forecast meteorological model versus machine learning")
plt.grid(True)
#plt.show(fig)
st.pyplot(fig)

#probabilistic results
prob = (np.concatenate((alg["pipe"].predict_proba(model_x_var),alg1["pipe"].predict_proba(model_x_var1)),axis =0)).transpose()
df_prob = pd.DataFrame(prob,index =alg["pipe"].classes_ ).T
df_prob = df_prob[labels]
df_prob.index = meteo_model[:48].index.strftime('%b %d %H:%M Z')

# Find the columns where all values are less than or equal to 5%
cols_to_drop = df_prob.columns[df_prob.apply(lambda x: x <= 0.05).all()]
df_prob.drop(cols_to_drop, axis=1, inplace=True)

#Display

fig1, ax = plt.subplots(figsize=(12, 9))
sns.heatmap(df_prob[:48], annot=True, cmap='coolwarm',
            linewidths=.6, linecolor='black',fmt='.0%',
           annot_kws={'size': 10})
plt.title('Probabilities wind direction more than 5%')
#plt.show(fig1)
st.pyplot(fig1)

#@title Wind intensity
st.markdown(" ### **Wind intensity knots**")
#open algorithm spd d0 d1
alg = pickle.load(open(algo_dir+"spd_"+OACI+"_d0.al","rb"))
alg1 = pickle.load(open(algo_dir+"spd_"+OACI+"_d1.al","rb"))

#select model variables
model_x_var = meteo_model[:24][alg["x_var"]]
model_x_var1 = meteo_model[24:48][alg1["x_var"]]

# forecat spd from ml and wrf
spd_ml = alg["pipe"].predict(meteo_model[:24][alg["x_var"]])
spd_ml1 = alg1["pipe"].predict(meteo_model[24:48][alg1["x_var"]])
df_for = pd.DataFrame({"time":meteo_model[:48].index,
                       "spd_WRF": np.concatenate((np.rint(model_x_var["mod0"]*1.94384),
                                                   np.rint(model_x_var1["mod0"]*1.94384)),axis=0),
                       "spd_ml": np.concatenate((np.rint(spd_ml*1.94384),
                                                  np.rint(spd_ml1*1.94384)),axis =0),})
df_for = df_for.set_index("time")

# concat metars an forecast
df_res = pd.concat([df_for,metars["spd_o"]],axis = 1)

#get mae
df_res_dropna = df_res.dropna()
mae_ml = round(mean_absolute_error(df_res_dropna.spd_o,df_res_dropna.spd_ml),2)
mae_wrf = round(mean_absolute_error(df_res_dropna.spd_o,df_res_dropna.spd_WRF),2)
if mae_ml < mae_wrf:
  score_ml+=1
  best_ml.append("wind speed")
if mae_ml > mae_wrf:
  score_wrf+=1
  best_wrf.append("wind speed")

#show results actual versus models
fig, ax = plt.subplots(figsize=(8,6))
df_res.dropna().plot(grid = True, ax=ax, linestyle='--', color = ["r","b","g"]);
# score references met model and machine learning
ref_met0 = alg["score"]["MAE_met"]
ref_ml0 = alg["score"]["MAE_ml"]
ref_met1 = alg1["score"]["MAE_met"]
ref_ml1 = alg1["score"]["MAE_ml"]
title = "Actual mean absolute error meteorological model (kt): {}. Reference (D0) (m/s): {}. Reference (m/s) (D1): {}\nActual mean absolute error machine learning (kt): {}. Reference (D0) (m/s): {}.Reference (D1) (m/s): {}".format(mae_wrf,ref_met0,ref_met1,mae_ml,ref_ml0,ref_ml1)
ax.set_title(title)
ax.grid(True, which = "both", axis = "both")
#plt.show(fig)
st.pyplot(fig)

# show forecasts
fig, ax = plt.subplots(figsize=(8,6))
df_for.plot(grid=True, ax=ax, color= ["r","b"],linestyle='--')
ax.set_title("Forecast meteorological model versus machine learning")
ax.grid(True, which = "both", axis = "both")
#plt.show(fig)
st.pyplot(fig)

#@title BR or FG
st.markdown(" ### **BR or FG**")
#open algorithm brfg d0 d1
alg = pickle.load(open(algo_dir+"brfg_"+OACI+"_d0.al","rb"))
alg1 = pickle.load(open(algo_dir+"brfg_"+OACI+"_d1.al","rb"))


#select model variables
model_x_var = meteo_model[:24][alg["x_var"]]
model_x_var1 = meteo_model[24:48][alg1["x_var"]]

# forecat br/fg from ml
brfg_ml = alg["pipe"].predict(model_x_var)
brfg_ml1 = alg1["pipe"].predict(model_x_var1)

#label metars br/fg data
metars["brfg_o_l"] = "No BR/FG"
mask = metars['wxcodes_o'].str.contains("BR")
metars.loc[mask,["brfg_o_l"]] = "BR/FG"
mask = metars['wxcodes_o'].str.contains("FG")
metars.loc[mask,["brfg_o_l"]] = "BR/FG"

#set up dataframe forecast machine learning
df_for = pd.DataFrame({"time": meteo_model[:48].index,
                       "brfg_ml": np.concatenate((brfg_ml,brfg_ml1),axis =0),})
df_for = df_for.set_index("time")

# concat metars an forecast
df_res = pd.concat([df_for,metars["brfg_o_l"]], axis = 1)
df_res_dropna = df_res.dropna()

#Heidke skill score ml
cm_ml = pd.crosstab(df_res.dropna().brfg_o_l, df_res.dropna().brfg_ml, margins=True,)
acc_ml = round(accuracy_score(df_res_dropna.brfg_o_l,df_res_dropna.brfg_ml),2)
HSS_ml = Hss(cm_ml)

#show results
print(" ### **BR or FG**")

fig1, ax = plt.subplots(figsize=(4,2))
sns.heatmap(cm_ml, annot=True, cmap='coolwarm',
            linewidths=.2, linecolor='black',)
plt.title("Confusion matrix\nAccuracy machine learning: {:.0%}".format(acc_ml))
#plt.show(fig1)
st.pyplot(fig1)

fig, ax = plt.subplots(figsize=(10,4))
plt.plot(df_res_dropna.index, df_res_dropna['brfg_ml'],marker="^", markersize=8,
         markerfacecolor='w', color="b",linestyle='');
plt.plot(df_res_dropna.index, df_res_dropna['brfg_o_l'],marker="*",markersize=8,
         markerfacecolor='w', color="g",linestyle='');
plt.legend(('brfg ml', 'brfg observed'),)
plt.grid(True,axis="both")
ref_ml0 = round(alg["score"]["HSS_ml"],2)
ref_ml1 = round(alg1["score"]["HSS_ml"],2)
plt.title("Actual Heidke skill score machine learning: {}. Reference (D0): {}. Reference (D1): {}".format(HSS_ml,ref_ml0,ref_ml1))
#plt.show(fig)
st.pyplot(fig)

fig, ax = plt.subplots(figsize=(10,4))
plt.plot(df_for.index, df_for['brfg_ml'],marker="^",linestyle='');
plt.title("Forecast machine learning")
plt.grid(True,axis="both")
#plt.show(fig)
st.pyplot(fig)

#show probabilistic results
prob = (np.concatenate((alg["pipe"].predict_proba(model_x_var),alg1["pipe"].predict_proba(model_x_var1)),axis =0)).transpose()
df_prob = (pd.DataFrame(prob,index =alg["pipe"].classes_ ).T.set_index(meteo_model[:48].index.map(lambda t: t.strftime('%d-%m %H'))))
fig, ax = plt.subplots(figsize=(10,8))
df_prob["BR/FG"] = df_prob["BR/FG"].round(1)
df_prob["BR/FG"].plot(ax = ax, grid = True, ylim =[0, 1], title = "BR or FG probability", kind='bar')
#plt.show(fig)
st.pyplot(fig)

#@title TS

try:
  print(" ### **TS**")
  st.markdown(" ### **TS**")  
  #open algorithm d0 d1
  alg = pickle.load(open(algo_dir+"ts_"+OACI+"_d0.al","rb"))
  alg1 = pickle.load(open(algo_dir+"ts_"+OACI+"_d1.al","rb"))

    
  #select model variables
  model_x_var = meteo_model[:24][alg["x_var"]]
  model_x_var1 = meteo_model[24:48][alg1["x_var"]]

  # forecat br/fg from ml
  ts_ml = alg["pipe"].predict(model_x_var)
  ts_ml1 = alg1["pipe"].predict(model_x_var1)

  #label metars br/fg data
  metars["ts_o_l"] = "No TS"
  mask = metars['wxcodes_o'].str.contains("TS")
  metars.loc[mask,["ts_o_l"]] = "TS"


  #set up dataframe forecast machine learning
  df_for = pd.DataFrame({"time": meteo_model[:48].index,
                        "ts_ml": np.concatenate((ts_ml,ts_ml1),axis =0),})
  df_for = df_for.set_index("time")

  # concat metars an forecast
  df_res = pd.concat([df_for,metars["ts_o_l"]], axis = 1)
  df_res_dropna = df_res.dropna()

  #Heidke skill score ml
  cm_ml = pd.crosstab(df_res.dropna().ts_o_l, df_res.dropna().ts_ml, margins=True,)
  acc_ml = round(accuracy_score(df_res_dropna.ts_o_l,df_res_dropna.ts_ml),2)
  HSS_ml = Hss(cm_ml)

  #show results
  fig1, ax = plt.subplots(figsize=(4,2))
  sns.heatmap(cm_ml, annot=True, cmap='coolwarm',
              linewidths=.2, linecolor='black',)
  plt.title("Confusion matrix\nAccuracy machine learning: {:.0%}".format(acc_ml))
  #plt.show(fig1)
  st.pyplot(fig1)
    
  fig, ax = plt.subplots(figsize=(10,4))
  plt.plot(df_res_dropna.index, df_res_dropna['ts_ml'],marker="^", markersize=8,
          markerfacecolor='w', color="b",linestyle='');
  plt.plot(df_res_dropna.index, df_res_dropna['ts_o_l'],marker="*",markersize=8,
          markerfacecolor='w', color="g",linestyle='');
  plt.legend(('ts ml', 'ts observed'),)
  plt.grid(True,axis="both")
  ref_ml0 = round(alg["score"]["HSS_ml"],2)
  ref_ml1 = round(alg1["score"]["HSS_ml"],2)
  plt.title("Actual Heidke skill score machine learning: {}. Reference (D0): {}. Reference (D1): {}".format(HSS_ml,ref_ml0,ref_ml1))
  #plt.show(fig)
  st.pyplot(fig)  
    
  fig, ax = plt.subplots(figsize=(10,4))
  plt.plot(df_for.index, df_for['ts_ml'],marker="^",linestyle='');
  plt.title("Forecast machine learning")
  plt.grid(True,axis="both")
  #plt.show(fig)
  st.pyplot(fig)  
    
  #show probabilistic results
  prob = (np.concatenate((alg["pipe"].predict_proba(model_x_var),alg1["pipe"].predict_proba(model_x_var1)),axis =0)).transpose()

  df_prob = (pd.DataFrame(prob,index =alg["pipe"].classes_ ).T.set_index(meteo_model[:48].index.map(lambda t: t.strftime('%d-%m %H'))))
  fig, ax = plt.subplots(figsize=(10,8))
  df_prob["TS"] = df_prob["TS"].round(1)
  df_prob["TS"].plot(ax = ax, grid = True, ylim =[0, 1], title = "TS probability", kind='bar')
  #plt.show(fig)
  st.pyplot(fig)  
except:
  print("*******")
  st.markdown(" #### ****")  

#@title Precipitation
st.markdown(" ### **Precipitation**")
#open algorithm prec d0 d1
alg = pickle.load(open(algo_dir+"prec_"+OACI+"_d0.al","rb"))
alg1 = pickle.load(open(algo_dir+"prec_"+OACI+"_d1.al","rb"))

#select model variables
model_x_var = meteo_model[:24][alg["x_var"]]
model_x_var1 = meteo_model[24:48][alg1["x_var"]]

# forecat prec from ml
prec_ml = alg["pipe"].predict(model_x_var)
prec_ml1 = alg1["pipe"].predict(model_x_var1)

#label metars prec data
metars["prec_o_l"] = "No RA/DZ"
mask = metars['wxcodes_o'].str.contains("RA")
metars.loc[mask,["prec_o_l"]] = "RA/DZ"
mask = metars['wxcodes_o'].str.contains("DZ")
metars.loc[mask,["prec_o_l"]] = "RA/DZ"

#label meteorological model prec0
prec0_l= ["RA/DZ" if c>0 else "No RA/DZ" for c in np.concatenate((model_x_var["prec0"],model_x_var1["prec0"]), axis=0)]

#set up dataframe forecast machine learning
df_for = pd.DataFrame({"time":meteo_model[:48].index,
                       "prec_WRF": prec0_l,
                       "prec_ml": np.concatenate((prec_ml,prec_ml1),axis =0),})
df_for = df_for.set_index("time")

# concat metars an forecast
df_res = pd.concat([df_for,metars["prec_o_l"]], axis = 1)
df_res_dropna = df_res.dropna()

#Heidke skill score ml
cm_ml = pd.crosstab(df_res.dropna().prec_o_l, df_res.dropna().prec_ml, margins=True,)
acc_ml = round(accuracy_score(df_res_dropna.prec_o_l,df_res_dropna.prec_ml),2)
HSS_ml = Hss(cm_ml)

#Heidke skill score meteorological model
cm_wrf = pd.crosstab(df_res.dropna().prec_o_l, df_res.dropna().prec_WRF, margins=True,)
HSS_wrf = Hss(cm_wrf)
acc_wrf = round(accuracy_score(df_res_dropna.prec_o_l,df_res_dropna.prec_WRF),2)
if acc_ml>acc_wrf:
  score_ml+=1
  best_ml.append("precipitation")
if acc_ml<acc_wrf:
  score_wrf+=1
  best_wrf.append("precipitation")


#show results
print(" ### **Precipitation**")
fig1, ax = plt.subplots(figsize=(4,2))
sns.heatmap(cm_ml, annot=True, cmap='coolwarm',
            linewidths=.2, linecolor='black',)
plt.title("Confusion matrix\nAccuracy machine learning: {:.0%}".format(acc_ml))
#plt.show(fig1)
st.pyplot(fig1)

fig1, ax = plt.subplots(figsize=(4,2))
sns.heatmap(cm_wrf, annot=True, cmap='coolwarm',
            linewidths=.2, linecolor='black',)
plt.title("Confusion matrix\nAccuracy meteorologic model: {:.0%}".format(acc_wrf))
#plt.show(fig1)
st.pyplot(fig1)

fig, ax = plt.subplots(figsize=(10,6))
plt.plot(df_res_dropna.index, df_res_dropna['prec_ml'],marker="^", markersize=8,
         markerfacecolor='w', color="b", linestyle='');
plt.plot(df_res_dropna.index, df_res_dropna['prec_o_l'],marker="*",markersize=8,
         markerfacecolor='w', color="g",linestyle='');
plt.plot(df_res_dropna.index, df_res_dropna['prec_WRF'],marker="v",markersize=8,
         markerfacecolor='w', color="r",linestyle='');
plt.legend(('prec ml', 'prec observed',"precipitation WRF"),)
plt.grid(True,axis="both")

ref_ml0 = round(alg["score"]["HSS_ml"],2)
ref_ml1 = round(alg1["score"]["HSS_ml"],2)
ref_met0 = round(alg["score"]["HSS_met"],2)
ref_met1 = round(alg1["score"]["HSS_met"],2)
plt.title("Actual Heidke skill score meteorological model: {}. Reference (D0): {}. Reference (D1): {}\nActual Heidke skill score machine learning: {}. Reference (D0): {}. Reference (D1): {}".format(HSS_wrf,ref_met0,ref_met1,HSS_ml,ref_ml0,ref_ml1))
#plt.show(fig)
st.pyplot(fig)

fig, ax = plt.subplots(figsize=(10,6))
plt.plot(df_for.index, df_for['prec_ml'],marker="^", markersize=8, markerfacecolor='w', color="b", linestyle='');
plt.plot(df_for.index, df_for['prec_WRF'],marker="v",markersize=8, markerfacecolor='w', color="r", linestyle='');
plt.legend(('prec ml', "precipitation WRF"),)
plt.title("Forecast machine learning versus WRF")
plt.grid(True,axis="both")
#plt.show(fig)
st.pyplot(fig)

#show probabilistic results
prob = (np.concatenate((alg["pipe"].predict_proba(model_x_var),alg1["pipe"].predict_proba(model_x_var1)),axis =0)).transpose()
df_prob = (pd.DataFrame(prob,index =alg["pipe"].classes_ ).T.set_index(meteo_model[:48].index.map(lambda t: t.strftime('%d-%m %H'))))
fig, ax = plt.subplots(figsize=(10,8))
df_prob["RA/DZ"] = df_prob["RA/DZ"].round(1)
df_prob["RA/DZ"].plot(ax=ax, grid=True, ylim =[0, 1], title = "Rain or drizzle probability",kind='bar')
#plt.show(fig)
st.pyplot(fig)


#@title Visibility
try:
    st.markdown(" ### **Horizontal visibility**")
    #open algorithm visibility d0 d1
    #alg = pickle.load(open("algorithms/vis_LEVX_1km_time_d0_p.al","rb")) #_p for a plus algorithm
    alg = pickle.load(open(algo_dir+"vis_"+OACI+"_d0.al","rb"))
    alg1 = pickle.load(open(algo_dir+"vis_"+OACI+"_d1.al","rb"))
    
    #select model variables
    model_x_var = meteo_model[:24][alg["x_var"]]
    model_x_var1 = meteo_model[24:48][alg1["x_var"]]
    
    # forecat vis from ml
    vis_ml = alg["pipe"].predict(model_x_var)
    vis_ml1 = alg1["pipe"].predict(model_x_var1)
    
    #label metars vis data
    metars["vis_o_l"] = ["<=1000m" if c<=1000 else ">1000m" for c in metars.visibility_o]
    
    #label meteorological model visibility0
    visibility0_l= ["<=1000m" if c<=1000 else ">1000m" for c in np.concatenate((model_x_var["visibility0"],model_x_var1["visibility0"]), axis=0)]
    
    #set up dataframe forecast machine learning
    df_for = pd.DataFrame({"time":meteo_model[:48].index,
                           "vis_WRF": visibility0_l,
                           "vis_ml": np.concatenate((vis_ml,vis_ml1),axis =0),})
    df_for = df_for.set_index("time")
    
    # concat metars an forecast
    df_res = pd.concat([df_for,metars["vis_o_l"]], axis = 1)
    df_res_dropna = df_res.dropna()
    
    #Heidke skill score ml
    cm_ml = pd.crosstab(df_res.dropna().vis_o_l, df_res.dropna().vis_ml, margins=True,)
    acc_ml = round(accuracy_score(df_res_dropna.vis_o_l,df_res_dropna.vis_ml),2)
    HSS_ml = Hss(cm_ml)
    
    #Heidke skill score meteorological model
    cm_wrf = pd.crosstab(df_res.dropna().vis_o_l, df_res.dropna().vis_WRF, margins=True,)
    acc_wrf = round(accuracy_score(df_res_dropna.vis_o_l,df_res_dropna.vis_WRF),2)
    HSS_wrf = Hss(cm_wrf)
    if acc_ml>acc_wrf:
      score_ml+=1
      best_ml.append("visibility")
    if acc_ml<acc_wrf:
      score_wrf+=1
      best_wrf.append("visibility")
    
    #show results
    print(" ### **Horizontal visibility**")
    
    fig1, ax = plt.subplots(figsize=(4,2))
    sns.heatmap(cm_ml, annot=True, cmap='coolwarm',
                linewidths=.2, linecolor='black',)
    plt.title("Confusion matrix\nAccuracy machine learning: {:.0%}".format(acc_ml))
    #plt.show(fig1)
    st.pyplot(fig1)
    
    fig1, ax = plt.subplots(figsize=(4,2))
    sns.heatmap(cm_wrf, annot=True, cmap='coolwarm',
                linewidths=.2, linecolor='black',)
    plt.title("Confusion matrix\nAccuracy meteorologic model: {:.0%}".format(acc_wrf))
    #plt.show(fig1)
    st.pyplot(fig1)
    
    fig, ax = plt.subplots(figsize=(10,4))
    plt.plot(df_res_dropna.index, df_res_dropna['vis_ml'],marker="^", markersize=8,
             markerfacecolor='w', color="b",linestyle='');
    plt.plot(df_res_dropna.index, df_res_dropna['vis_o_l'],marker="*",markersize=8,
             markerfacecolor='w', color="g",linestyle='');
    plt.plot(df_res_dropna.index, df_res_dropna['vis_WRF'],marker="v",markersize=8,
             markerfacecolor='w',color="r", linestyle='');
    plt.legend(('vis ml', 'vis observed',"vis WRF"),)
    plt.grid(True, axis="both")
    ref_ml0 = round(alg["score"]["HSS_ml"],2)
    ref_ml1 = round(alg1["score"]["HSS_ml"],2)
    ref_met0 = round(alg["score"]["HSS_met"],2)
    ref_met1 = round(alg1["score"]["HSS_met"],2)
    plt.title("Actual Heidke skill score meteorological model: {}. Reference (D0): {}. Reference (D1): {}\nActual Heidke skill score machine learning: {}. Reference (D0): {}. Reference (D1): {}".format(HSS_wrf,ref_met0,ref_met1,HSS_ml,ref_ml0,ref_ml1))
    #plt.show(fig)
    st.pyplot(fig)
    
    fig, ax = plt.subplots(figsize=(10,4))
    plt.plot(df_for.index, df_for['vis_ml'],marker="^", markersize=8,
             markerfacecolor='w', color="b",linestyle='');
    plt.plot(df_for.index, df_for['vis_WRF'],marker="v",markersize=8,
             markerfacecolor='w', color="r",linestyle='');
    plt.title("Forecast machine learning")
    plt.grid(True,axis="both")
    #plt.show(fig)
    st.pyplot(fig)
    
    #show probabilistic results
    prob = (np.concatenate((alg["pipe"].predict_proba(model_x_var),alg1["pipe"].predict_proba(model_x_var1)),axis =0)).transpose()
    df_prob = (pd.DataFrame(prob,index =alg["pipe"].classes_ ).T.set_index(meteo_model[:48].index.map(lambda t: t.strftime('%d-%m %H'))))
    fig, ax = plt.subplots(figsize=(10,8))
    df_prob["<=1000m"] =df_prob["<=1000m"].round(1)
    df_prob["<=1000m"].plot(ax=ax, grid=True, ylim =[0, 1], title="Horizontal visibility below 1000 meters probability", kind='bar')
    #plt.show(fig)
    st.pyplot(fig)
except:
    print("*******")
    st.markdown(" #### ****")  

#@title Cloud cover
try:
    st.markdown(" ### **Cloud cover level 1**")

    #open algorithm skyc1 d0 d1
    alg = pickle.load(open(algo_dir+"skyc1_"+OACI+"_d0.al","rb"))
    alg1 = pickle.load(open(algo_dir+"skyc1_"+OACI+"_d1.al","rb"))

    #select model variables
    model_x_var = meteo_model[:24][alg["x_var"]]
    model_x_var1 = meteo_model[24:48][alg1["x_var"]]

    # forecat spd from ml
    skyc1_ml = alg["pipe"].predict(model_x_var)
    skyc1_ml1 = alg1["pipe"].predict(model_x_var1)

    #set up dataframe forecast machine learning and WRF
    df_for = pd.DataFrame({"time":meteo_model[:48].index,
                           "skyc1_ml": np.concatenate((skyc1_ml,skyc1_ml1),axis =0),})
    df_for = df_for.set_index("time")

    # concat metars an forecast
    df_res = pd.concat([df_for,metars["skyc1_o"]],axis = 1)

    #get accuracy
    df_res_dropna = df_res.dropna()
    acc_ml = round(accuracy_score(df_res_dropna.skyc1_o,df_res_dropna.skyc1_ml),2)
    cm_ml = pd.crosstab(df_res.dropna().skyc1_o, df_res.dropna().skyc1_ml, margins=True,)

    #show results
    fig1, ax = plt.subplots(figsize=(4,2))
    sns.heatmap(cm_ml, annot=True, cmap='coolwarm',
                linewidths=.2, linecolor='black',)
    plt.title("Confusion matrix\nAccuracy machine learning: {:.0%}".format(acc_ml))
    #plt.show(fig)
    st.pyplot(fig1)

    fig, ax = plt.subplots(figsize=(10,6))
    plt.plot(df_res_dropna.index, df_res_dropna['skyc1_ml'], marker="^", markersize=8,
             markerfacecolor='w', color="b", linestyle='')
    plt.plot(df_res_dropna.index, df_res_dropna['skyc1_o'], marker="*", markersize=13,
             markerfacecolor='k', color="g", linestyle='');
    plt.legend(('Cloud cover ml', 'Cloud cover observed'),)
    plt.grid(True)
    ref_ml0 = round(alg["score"]["acc_ml"],2)
    ref_ml1 = round(alg1["score"]["acc_ml"],2)
    plt.title("Actual accuracy machine learning: {:.0%}. Reference (D0): {:.0%}. Reference (D1): {:.0%}".format(acc_ml,ref_ml0,ref_ml1))
    #plt.show(fig)
    st.pyplot(fig)

    fig, ax = plt.subplots(figsize=(10,6))
    plt.plot(df_for.index, df_for['skyc1_ml'],marker="^",linestyle='');
    plt.title("Forecast machine learning")
    plt.grid(True)
    #plt.show(fig)
    st.pyplot(fig)

    #show probabilistic results
    prob = (np.concatenate((alg["pipe"].predict_proba(model_x_var),alg1["pipe"].predict_proba(model_x_var1)),axis =0)).transpose()
    df_prob = (pd.DataFrame(prob,index =alg["pipe"].classes_ ).T.set_index(meteo_model[:48].index))

    # Find the columns where all values are less than or equal to 5%
    cols_to_drop = df_prob.columns[df_prob.apply(lambda x: x <= 0.05).all()]
    df_prob.drop(cols_to_drop, axis=1, inplace=True)
    df_prob.index = df_prob.index.strftime('%d %H:%M')

    fig1, ax = plt.subplots(figsize=(5, 9))
    sns.heatmap(df_prob.iloc[:,:-1], annot=True, cmap='coolwarm',
                linewidths=.6, linecolor='black',fmt='.0%',
               annot_kws={'size': 10})
    plt.title('Sky cloud cover probabilities')
    #plt.show(fig1)
    st.pyplot(fig1)

except:
    print("*******")
    st.markdown(" #### ****") 
    
#@title Cloud height level1
try:
    st.markdown(" ### **Cloud height level 1**")

    #open algorithm skyc1 d0 d1
    alg = pickle.load(open(algo_dir+"skyl1_"+OACI+"_d0.al","rb"))
    alg1 = pickle.load(open(algo_dir+"skyl1_"+OACI+"_d1.al","rb"))

    #select model variables
    model_x_var = meteo_model[:24][alg["x_var"]]
    model_x_var1 = meteo_model[24:48][alg1["x_var"]]

    # forecat spd from ml
    skyl1_ml = alg["pipe"].predict(model_x_var)
    skyl1_ml1 = alg1["pipe"].predict(model_x_var1)

    #set up dataframe forecast machine learning and WRF
    df_for = pd.DataFrame({"time":meteo_model[:48].index,
                           "skyl1_ml": np.concatenate((skyl1_ml,skyl1_ml1),axis =0),})
    df_for = df_for.set_index("time")

    #clouds height to feet or "M" no clooud
    num = pd.to_numeric(metars.skyl1_o, errors="coerce")*1

    #label more or less than 200 feet
    interval = pd.IntervalIndex.from_tuples([(-1, 300),(300,7000)])
    labels = ["<=300ft",">300ft"]
    metars["skyl1_l"] = pd.cut(num, bins=interval,retbins=False,labels=labels)
    metars["skyl1_l"] = metars["skyl1_l"].map({a:b for a,b in zip(interval,labels)})
    metars["skyl1_l"] = metars["skyl1_l"].astype(str).replace("nan","No Cloud")
    metars["skyl1_l"] = pd.Categorical(metars["skyl1_l"])
    # concat metars an forecast
    df_res = pd.concat([df_for,metars["skyl1_l"]],axis = 1)

    #get accuracy
    df_res_dropna = df_res.dropna()
    acc_ml = round(accuracy_score(df_res_dropna.skyl1_l,df_res_dropna.skyl1_ml),2)
    cm_ml = pd.crosstab(df_res.dropna().skyl1_l, df_res.dropna().skyl1_ml, margins=True,)

    #show results
    fig1, ax = plt.subplots(figsize=(4,2))
    sns.heatmap(cm_ml, annot=True, cmap='coolwarm',
                linewidths=.2, linecolor='black',)
    plt.title("Confusion matrix\nAccuracy machine learning: {:.0%}".format(acc_ml))
    #plt.show(fig)
    st.pyplot(fig1)

    fig, ax = plt.subplots(figsize=(10,6))
    plt.plot(df_res_dropna.index, df_res_dropna['skyl1_ml'], marker="^", markersize=8,
             markerfacecolor='w', color="b", linestyle='')
    plt.plot(df_res_dropna.index, df_res_dropna['skyl1_l'], marker="*", markersize=13,
             markerfacecolor='k', color="g", linestyle='');
    plt.legend(('Cloud cover ml', 'Cloud cover observed'),)
    plt.grid(True)
    ref_ml0 = round(alg["score"]["acc_ml"],2)
    ref_ml1 = round(alg1["score"]["acc_ml"],2)
    plt.title("Actual accuracy machine learning: {:.0%}. Reference (D0): {:.0%}. Reference (D1): {:.0%}".format(acc_ml,ref_ml0,ref_ml1))
    #plt.show(fig)
    st.pyplot(fig)

    fig, ax = plt.subplots(figsize=(10,6))
    plt.plot(df_for.index, df_for['skyl1_ml'],marker="^",linestyle='');
    plt.title("Forecast machine learning")
    plt.grid(True)
    #plt.show(fig)
    st.pyplot(fig)

    #show probabilistic results
    prob = (np.concatenate((alg["pipe"].predict_proba(model_x_var),alg1["pipe"].predict_proba(model_x_var1)),axis =0)).transpose()
    df_prob = (pd.DataFrame(prob,index =alg["pipe"].classes_ ).T.set_index(meteo_model[:48].index))

    # Find the columns where all values are less than or equal to 5%
    cols_to_drop = df_prob.columns[df_prob.apply(lambda x: x <= 0.05).all()]
    df_prob.drop(cols_to_drop, axis=1, inplace=True)
    df_prob.index = df_prob.index.strftime('%d %H:%M')

    fig1, ax = plt.subplots(figsize=(5, 9))
    sns.heatmap(df_prob.iloc[:,:-1], annot=True, cmap='coolwarm',
                linewidths=.6, linecolor='black',fmt='.0%',
               annot_kws={'size': 10})
    plt.title('Sky cloud height level probabilities')
    #plt.show(fig1)
    st.pyplot(fig1)

except:
    print("*******")
    st.markdown(" #### ****") 



#@title Temperature

#open algorithm temperature d0 d1
alg = pickle.load(open(algo_dir+"temp_"+OACI+"_d0.al","rb"))
alg1 = pickle.load(open(algo_dir+"temp_"+OACI+"_d1.al","rb"))

#select model variables
model_x_var = meteo_model[:24][alg["x_var"]]
model_x_var1 = meteo_model[24:48][alg1["x_var"]]

# forecat temperature from ml
temp_ml = alg["pipe"].predict(meteo_model[:24][alg["x_var"]])
temp_ml1 = alg1["pipe"].predict(meteo_model[24:48][alg1["x_var"]])
df_for = pd.DataFrame({"time":meteo_model[:48].index,
                       "temp_WRF": np.concatenate((np.rint(model_x_var["temp0"]-273.16),
                                                   np.rint(model_x_var1["temp0"]-273.16)),axis=0),
                       "temp_ml": np.concatenate((np.rint(temp_ml-273.16),np.rint(temp_ml1-273.16)),axis =0),})
df_for = df_for.set_index("time")


# concat metars an forecast
df_res = pd.concat([df_for,metars["temp_o"]],axis = 1)

#get mae
df_res_dropna = df_res.dropna()
mae_ml = round(mean_absolute_error(df_res_dropna.temp_o,df_res_dropna.temp_ml),2)
mae_wrf = round(mean_absolute_error(df_res_dropna.temp_o,df_res_dropna.temp_WRF),2)
if mae_ml < mae_wrf:
  score_ml+=1
  best_ml.append("temperature")
if mae_ml > mae_wrf:
  score_wrf+=1
  best_wrf.append("temperature")

#print results
print(" #### **Temperature Celsius**")
st.markdown(" #### **Temperature Celsius**")

fig, ax = plt.subplots(figsize=(10,6))
df_res.dropna().plot(grid=True, ax=ax, color=["r","b","g"],linestyle='--');
# score references met model and machine learning
ref_met0 = alg["score"]["MAE_met"]
ref_ml0 = alg["score"]["MAE_ml"]
ref_met1 = alg1["score"]["MAE_met"]
ref_ml1 = alg1["score"]["MAE_ml"]
title = "Actual mean absolute error meteorological model : {}. Reference (D0) : {}. Reference (D1): {}\nActual mean absolute error machine learning: {}. Reference (D0): {}. Reference (D1): {}".format(mae_wrf,ref_met0,ref_met1,mae_ml,ref_ml0,ref_ml1)
ax.set_title(title)
ax.grid(True, which = "both", axis = "both")
#plt.show(fig)
st.pyplot(fig)

fig, ax = plt.subplots(figsize=(10,6))
df_for.plot(grid=True, ax=ax, color= ["r","b"],linestyle='--')
ax.set_title("Forecast meteorological model versus machine learning")
ax.grid(True, which = "both", axis = "both")
#plt.show(fig)
st.pyplot(fig)



#@title Mean sea level pressure

#open algorithm temperature d0 d1
alg = pickle.load(open(algo_dir+"pres_"+OACI+"_d0.al","rb"))
alg1 = pickle.load(open(algo_dir+"pres_"+OACI+"_d1.al","rb"))

#select model variables
model_x_var = meteo_model[:24][alg["x_var"]]
model_x_var1 = meteo_model[24:48][alg1["x_var"]]

# forecat mean sea level pressure from ml and wrf
pres_ml = alg["pipe"].predict(meteo_model[:24][alg["x_var"]])
pres_ml1 = alg1["pipe"].predict(meteo_model[24:48][alg1["x_var"]])
df_for = pd.DataFrame({"time":meteo_model[:48].index,
                       "mslp_WRF": np.concatenate((np.rint(model_x_var["mslp0"]/100),
                                                   np.rint(model_x_var1["mslp0"]/100)),axis=0),
                       "mslp_ml": np.concatenate((np.rint(pres_ml),np.rint(pres_ml1)),axis =0),})
df_for = df_for.set_index("time")


# concat metars an forecast
df_res = pd.concat([df_for,metars["mslp_o"]],axis = 1)

#get mae
df_res_dropna = df_res.dropna()
mae_ml = round(mean_absolute_error(df_res_dropna.mslp_o,df_res_dropna.mslp_ml),2)
mae_wrf = round(mean_absolute_error(df_res_dropna.mslp_o,df_res_dropna.mslp_WRF),2)
if mae_ml < mae_wrf:
  score_ml+=1
  best_ml.append("pressure")
if mae_ml > mae_wrf:
  score_wrf+=1
  best_wrf.append("pressure")

#print results
print("#### **Pressure hectopascals**")
st.markdown("#### **Pressure hectopascals**")
fig, ax = plt.subplots(figsize=(10,6))
df_res.dropna().plot(grid=True, ax=ax, color=["r","b","g"],linestyle='--');
# score references met model and machine learning
ref_met0 = alg["score"]["MAE_met"]
ref_ml0 = alg["score"]["MAE_ml"]
ref_met1 = alg1["score"]["MAE_met"]
ref_ml1 = alg1["score"]["MAE_ml"]
title = "Actual mean absolute error meteorological model : {}. Reference (D0) : {}. Reference (D1): {}\nActual mean absolute error machine learning: {}. Reference (D0): {}. Reference (D1): {}".format(mae_wrf,ref_met0,ref_met1,mae_ml,ref_ml0,ref_ml1)
ax.set_title(title)
ax.grid(True, which = "both", axis = "both")
#plt.show(fig)
st.pyplot(fig)

# Create the plot
fig, ax = plt.subplots(figsize=(10,6))
df_for.plot(grid=True, ax=ax, color=["r","b"],linestyle='--')
ax.set_title("Forecast meteorological model versus machine learning")
ax.grid(True, which = "both", axis = "both")
#plt.show(fig)
st.pyplot(fig)

#global results
st.write("#### **Global results airport:**")
st.write(OACI)
st.write("Better meteorological model outcome: {}".format(score_wrf))
st.write(best_wrf)
st.write("Better machine learning outcome: {}".format(score_ml))
st.write(best_ml)



